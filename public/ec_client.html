<html>
<head>

 <script type="text/javascript" src="elliptic.js"></script>
 <script type="text/javascript" src="bn.js"></script>
 <script type="text/javascript" src="bundle.js"></script>
 <script type="text/javascript" src="itemKNN.js"></script> 

 <script src="/socket.io/socket.io.js"></script>
</head>

<body>
 
<script>
"use strict"  
window.onload = function( ) {

	function encode_point(curve, point) {
		switch (curve.type) { 
			case "edwards":
				point = point.toP();
				return ( point.isInfinity() ) ? [null] : [point.getY().mod(curve.two).isOdd(), point.getX()]
			default:
				return ( point.isInfinity() ) ? [ null , null ] : [ point.getX() , point.getY() ]
		}
	}

	function decode_point(curve, p) {
		switch (curve.type) { 
			case "edwards":
				return (p[0] == null) ? curve.point(null,null,null) : curve.pointFromX(p[0],p[1])
			default:
				return curve.point(p[0], p[1])
		}
	}

	function sample_geom(p) { return Math.ceil( Math.log( 1 - Math.random() ) / Math.log( 1 - p ) ) };
 
	function generate_keys(mycurve, shares, x, L){

		var sub_array =[];
		var idx = -1;
		shares = shares.map( function(p,i) { 
			var point = decode_point(mycurve.curve, p);
			if (point.isInfinity()) idx = i;
			return encode_point(mycurve.curve, point.mul(x)).join(16); 
		})

		console.assert(idx >= 0);
		
		for (var l = 0; l < L; l++) {					
			var kil = shares.reduce( function(sum, y, j) {
				var H = ( idx!=j ? new BN( mycurve.hash().update( y + l ).digest('hex')).toRed(BN.red()) : mycurve.curve.zero );
				return sum.add( (idx > j ? H.neg() : H ) )  } , mycurve.curve.zero );			
			sub_array.push(kil);		
		};

		return sub_array;
	}

	function ec_encrypt(values, keys, curve){
		
		console.assert(values.length == keys.length);
		var encrypted = [ ];
		for (var i = 0; i < keys.length; i++) {
			var point = curve.g.mul( keys[i].add( new BN(values[i].toString(), 10) ).mod(curve.n) ); 
			encrypted[i] = encode_point(curve, point); 			
		}

		return encrypted;
	}  
  
  	var d = new Date();
			
  	//connection
  	try{
		var socket = io.connect('http://localhost:3002');
	} 
	catch(err) { 
		alert("Server not found")
	}
			
	function onModel(message) {
        
        var params = message.params;
        var createCountMinSketch = require('count-min').createCountMinSketch;
        var aggregated_sketch = createCountMinSketch(params.accuracy, params.probIncorrect, params.samples);
        

        var D = message.data.depth;
        var W = message.data.width;

        var k = message.data.table.slice(0,W).reduce(function(prev,a){return prev + a}, 0);
        
        console.assert(k > 0);

        for (var i = 0; i < D; i++) {
        	console.assert(k == message.data.table.slice(i*W,i*W + W).reduce(function(prev,a){return prev + a}, 0) );
        };
        
        aggregated_sketch.fromJSON(message.data);
        console.log("--Aggregate data received");
        	
        var n = Math.sqrt(params.samples*2);
        var simMatrix  = require('itemKNN').NNmodelBuilding(aggregated_sketch, n )

        // new observation
		var feedback = [ ];
		for (var i = 0; i < n; i++) {
		    feedback[i] = [ ];
		    for (var j = 0; j <= i; j++) {
		        feedback[i][j] = feedback[j][i] = sample_geom(0.3) % 2;
		    }
		}
		
        var topNN = 10;
        var topKNN = require('itemKNN').NNprediction(feedback,simMatrix,topNN);
		
		console.log("Top",topNN,"recommended items:",topKNN);
        		
	}


	function onShare(message) {
		
		var params = { };
		var aggregated_sketch = {};
        	
        params = message.data
        params.x = new BN(params.x.toString(),16)

        console.log(params);

        //elliptic curve
        params.mycurve = ellipticjs.curves.p256;
        params.mycurve = ellipticjs.curves.ed25519;
        
        
        // sketch generation
		var createCountMinSketch = require('count-min').createCountMinSketch;
		var sketch = createCountMinSketch(parseFloat(params.accuracy), parseFloat(params.probIncorrect), parseInt(params.samples));
		
		for (var i = 0; i < params.n_prog; i++ )
			sketch.update(i, sample_geom(0.3) % 2 );
			
		var json_sketch = sketch.toJSON();
        
        console.assert(params.shares != undefined);
        console.assert(params.x != undefined);
        var keys = generate_keys(params.mycurve, params.shares, params.x, json_sketch.width * json_sketch.depth);

		//sketch encryption
		console.log("--Encryption phase")
		json_sketch.table = ec_encrypt(json_sketch.table, keys, params.mycurve.curve );
		console.log("--Data encrypted")

		socket.emit("user-view",{"username" : d.toISOString(), "sketch" : json_sketch});
		console.log("--Data sent to the aggregator")
	}

	//registration
	socket.emit("add-user", {"username": d.toISOString()});
		
	socket.on("share", onShare );
         	
    socket.on("model", onModel );
         
	//case of too many connections
	socket.on("too-many-connections", function(){
		console.log("--Too many connections");
	});
	
	socket.on("disconnect", function( ){ 
		console.log("--Disconnected!..");
		socket.destroy();
	});
	
	socket.on("error", function(){ 
		console.log("--Error");
		socket.destroy()
	});

}
  </script>
</body>
</html>
